(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const listModule = require('./listModule');
const cardModule = require('./cardModule');
const tagModule = require('./tagModule');
const utilsModule = require('./utilsModule');

const app = {
  base_url: 'http://localhost:5050',

  // init function, launched upon page load
  init: async function () {
    console.log('app.init !');

    // we dispatch the base_url info to the modules which need it
    listModule.setBaseUrl(app.base_url);
    cardModule.setBaseUrl(app.base_url);
    tagModule.setBaseUrl(app.base_url);

    // upon page load, we want to get the existsing lists in DB
    // we declared the init method as async: we can wait for the getListsFromAPI function to finish before running the next instructions
    await app.getListsFromAPI();
    await tagModule.getTagsFromAPI();
    // adding method that hooks event listeners
    app.addListenerToActions();
  },

  addListenerToActions: () => {
    // on the add list button, we add an event listener to open the modal
    const button = document.getElementById('addListButton');
    button.addEventListener('click', listModule.showAddListModal);

    // on the add tag button, we add an event listener to open the add tag modal
    const addTagButton = document.getElementById('addTagButton');
    addTagButton.addEventListener('click', tagModule.showAddTagForm);

    // we target the close and X buttons and the modal background to add an event listerner to them, which will close the modal
    const closeElements = document.querySelectorAll('.close, .modal-close, .modal-background');
    for (const closeElement of closeElements) {
      closeElement.addEventListener('click', utilsModule.hideModals);
    }

    // we target the add list form modal 
    const form = document.querySelector('#addListModal form');
    form.addEventListener('submit', app.handleAddListForm);

    // we target the add card form modal
    const cardForm = document.querySelector('#addCardModal form');
    cardForm.addEventListener('submit', app.handleAddCardForm);

    // we capture the submit event generated by the add tag form
    const addTagForm = document.querySelector('#addTagModal form');
    addTagForm.addEventListener('submit', tagModule.handleAddTagForm);

    // we capture the submit event generated by the associate tag form
    const aassociateTagForm = document.querySelector('#associateTagModal form');
    aassociateTagForm.addEventListener('submit', tagModule.handleAssociateLabelForm);

  },


  handleAddListForm: event => {
    // to make sure listModule doesn't have to refer to app in its code, we leave the declaration fo the method in app
    // we delegate the list-specific processing to the module and we clode the modals form app 
    listModule.handleAddListForm(event);
    utilsModule.hideModals();
  },

  handleAddCardForm: event => {
    cardModule.handleAddCardForm(event);
    utilsModule.hideModals();
  },
  getListsFromAPI: async () => {
    try {
      const result = await fetch(`${app.base_url}/lists`);
      if (result.ok) {

        const listArray = await result.json();
        // with fetch, we get an array of list objects
        // To create the lists in the DOM, we loop on this array and, for each element, we call the makeListInDOM method

        for (const list of listArray) {
          listModule.makeListInDOM(list);
          // for each element of the lists array, we use the cards property which contains a cards array for this list
          // we loop on this array and, for each element, we call the makeCardInDOM method
          for (const card of list.cards) {
            cardModule.makeCardInDOM(card);
            // if we have elements in the tags property of the card, we loop through the array to create an element per tag
            if (card.tags) {
              for (const tag of card.tags) {
                tagModule.makeTagInDOM(tag, card.id);
              }
            }
          }
        }
      } else {
        console.error('Pépin au niveau du serveur');
      }

      // we call SortableJS to implement the drag-and-drop
      // here we delcare the list container as a place where elements can be dragged
      // the elements to be dragged (individual lists) are specified in the 'draggable' property
      // when the element dragging ends, we trigger the listModule.handleDropList method
      let container = document.querySelector('.card-lists');
      new Sortable(container, {
        group: "project",
        draggable: ".list-item",
        onEnd: listModule.handleDropList
      });

    } catch (error) {
      console.error('Impossible de charger les listes depuis l\'API', error);
    }
  }
}

// we hook an event listener on the document: when the loading is done, app.init is launched
document.addEventListener('DOMContentLoaded', app.init);

module.exports = app;
},{"./cardModule":2,"./listModule":3,"./tagModule":4,"./utilsModule":5}],2:[function(require,module,exports){
const tagModule = require('./tagModule');

const cardModule = {

  base_url: null,

  setBaseUrl: url => {
    cardModule.base_url = url;
  },

  showAddCardModal: event => {
    // we get the value of data-list-id by using the reference to the clicked element
    const listId = event.target.closest('.is-one-quarter').getAttribute('data-list-id');
    const div = document.getElementById('addCardModal');
    // we update the value attribute in the hidden field of the form
    div.querySelector('input[name="list_id"]').value = listId;
    div.classList.add('is-active');
    div.querySelector('input').value = '';
  },

  handleAddCardForm: async (event) => {
    // we deactivate the default behaviour
    event.preventDefault();
    // we get the form info and save them into a FormData object
    const formData = new FormData(event.target);

    // we calculate the position of our new card
    // we select the new card based on the value of list_id we have in the formData object
    // to respect the selection syntax for an attribute, we have to specify the value of list_id as a string
    // [data-list-id=12] would be incorrect, we have to specify [data-list-id="12"]
    const position = document.querySelectorAll(`[data-list_id="${formData.get('list_id')}"] .box`).length;
    formData.set('position', position);

    try {
      // we wait for the DB to answer before going on
      // thanks to multer which was added to our API, we can directly pass the formData object in the request's body
      // Express will know how to extract the info and place them in request.body
      const result = await fetch(`${cardModule.base_url}/cards`, {
        method: 'POST',
        body: formData
      });

      // we test whether the request succeeded (status 200) 
      if (result.ok) {
        const json = await result.json();
        console.log('makeCardinDOM in hdanleCardForm');
        cardModule.makeCardInDOM(json);
      } else {
        console.error('On a eu un pépin sur le serveur');
      }


    } catch (error) {
      console.error('Impossible d\'ajouter la carte', error);
    }
  },


  makeCardInDOM: data => {
    // we grab the card template
    const template = document.getElementById('cardTemplate');
    // we create a new node by cloning our template
    const node = document.importNode(template.content, true);
    // we set up the new card
    node.querySelector('.column').textContent = data.content;

    // we select the card container based on its CSS class
    const box = node.querySelector('.box');
    console.log(typeof(data.color));
    box.style.backgroundColor = data.color;
    box.setAttribute('data-card-id', data.id);

    // we hook an event listener on the <a> tag which contains the pencil icon
    const editLink = box.querySelector('.fa-pencil-alt').closest('a');
    editLink.addEventListener('click', cardModule.showCardTitleForm);

    //o we add an event listener to the <a> tag which contains the bin icon
    const deleteLink = box.querySelector('.fa-trash-alt').closest('a');
    deleteLink.addEventListener('click', cardModule.deleteCard);

    // we hook an event listener to watch for submit events of the edit form
    box.querySelector('form').addEventListener('submit', cardModule.handleCardTitleForm);
    // and for clicks on cancel button
    box.querySelector('button.cancel-edit-card').addEventListener('click', cardModule.closeCardEditForm);

    box.querySelector('.tag-associate-button-column').addEventListener('click', tagModule.showAssociateLabelForm);

    // we add the node at the right place in the DOM
    // we target the html element which has a data-list-id attribute whose value is the same as list_id in our form
    // in this element, we target the sub-element with '.panel-block' class: this element is the one containing the cards of a list
    // we add our new card in that element
    document.querySelector(`[data-list-id="${data.list_id}"] .panel-block`).appendChild(node);
  },

  deleteCard: async event => {
    // asking the user to confirm deletion
    if (!confirm('Supprimer cette carte ?')) {
      // if the user answers no, we exit the method without executing the rest of the code
      return;
    }

    // we identify the card to delete based on our event.target
    const card = event.target.closest('.box');

    // we get the id of the card
    const cardId = card.getAttribute('data-card-id');

    // fetch reguest
    // DELETE /cards/:id
    try {

      const result = await fetch(`${cardModule.base_url}/cards/${cardId}`, {
        method: 'DELETE'
      });

      if (result.ok) {
        // if all went well, we delete the card in DOM
        card.remove();
      } else {
        // if not, we display an error message
        console.error('On a eu un pépin sur le serveur');
      }
    } catch (error) {
      console.error('Impossible de supprimer cette carte', error);
    }

  },

  showCardTitleForm: event => {
    // we target the container div of a card
    const div = event.target.closest('.box');
    // we hide the div containing the title of the card
    const title = div.querySelector('.column');
    title.classList.add('is-hidden');
    // we hide the action buttons
    div.querySelector('.card-actions-group').classList.add('is-hidden');

    // we display the edit form
    div.querySelector('form').classList.remove('is-hidden');
    // in the input of the form, we add the title of the card as value
    div.querySelector('[name="content"]').value = title.textContent;

  },

  handleCardTitleForm: async event => {
    // we deactivate the default behaviour to avoid page reload
    event.preventDefault();
    // we centralize the form data in a FormData object
    const formData = new FormData(event.target);

    // we check whether the user did type in something in the title field
    // if not, we exit the function and we display an error
    if (formData.get('content') === '') {
      console.error('Veuillez saisir un titre pour cette carte');
      return;
    }

    const title = event.target.closest('.box').querySelector('.column');
    const div = event.target.closest('.box');

    try {
      // we update the card record in DB via request sent to our API
      const result = await fetch(`${cardModule.base_url}/cards/${event.target.closest('.box').getAttribute('data-card-id')}`, {
        method: 'PATCH',
        body: formData
      });

      for (var pair of formData.entries()) {
        console.log(pair[0]+ ', ' + pair[1]); 
    }

      if (result.ok) {
        const json = await result.json();
        if (json) {
          // the update was successful
          // we select the div which contains the title to update it
          title.textContent = formData.get('content');
          if (formData.get('color')) {
            div.style.backgroundColor = formData.get('color');
          }
          console.log(div.querySelector('.card-actions-group'));
          div.querySelector('.card-actions-group').classList.remove('is-hidden');
        } else {
          console.error('Aucune carte mise à jour');
        }
      } else {
        console.error('On a eu un pépin sur le serveur');
      }
    } catch (error) {
      console.error('Impossible de mettre la carte à jour', error);
    } finally {
      title.classList.remove('is-hidden');
      event.target.classList.add('is-hidden');
    }
  },
  closeCardEditForm: (event) => {
    const editForm = event.target.closest('form[method="PATCH"]');
    editForm.classList.add('is-hidden');

    // we target the container div of a card
    const div = event.target.closest('.box');
    // we show again the div containing the title of the card
    const title = div.querySelector('.column');
    title.classList.remove('is-hidden');
    // we show again the action buttons
    div.querySelector('.card-actions-group').classList.remove('is-hidden');
  }
};

module.exports = cardModule;
},{"./tagModule":4}],3:[function(require,module,exports){
const cardModule = require('./cardModule');

const listModule = {

  base_url: null,

  setBaseUrl: url => {
    listModule.base_url = url;
  },

  showAddListModal: () => {
    const div = document.getElementById('addListModal');
    div.classList.add('is-active');
    div.querySelector('input').value ='';
  },

  handleAddListForm: async event => {
    // we deactivate the default behaviour to avoid page reload
    event.preventDefault();
    // we get the form data and save them into a FormData object
    // FormData can extract all the inputs inside a <form> element, whatever their nesting level in the html document
    const formData = new FormData(event.target);

    // we give a value to the position field in our new list
    const position = document.querySelectorAll('.is-one-quarter').length;
    formData.set('position', position);

    try {

      // we use fetch with POST method to send the info to the API and add the new list in DB
      const result = await fetch(`${listModule.base_url}/lists`, {
        method: 'POST',
        body: formData
      });

      if (result.ok) {
        const json = await result.json();
        listModule.makeListInDOM(json);
      } else {
        console.error('On a eu un pépin sur le serveur');
      }

    } catch (error) {
      console.error('Impossible d\'ajouter la liste', error);
    }
  },

  makeListInDOM: data => {
    // we grab the list template
    const template = document.getElementById('listTemplate');
    // we create a new html node by cloning the template AND including all the elements it contains
    const node = document.importNode(template.content, true);

    // now we use the JSON object we received as a parameter to set up our new HTML element
    const h2 = node.querySelector('h2');
    h2.textContent = data.name;
    // we make the h2 react to double-click in order to display the edit form
    h2.addEventListener('dblclick', listModule.showListNameForm);

    // we watch for click events on cancel button
    node.querySelector('.cancel-edit-list-button').addEventListener('click', listModule.closeEditListForm);

    // we add an event listener for submit events on the edit form
    node.querySelector('form').addEventListener('submit', listModule.handleListNameForm);


    // we take advantage of the creation step to update the info stored in attributes with the data we got from the DB: name and list_id
    node.querySelector('.is-one-quarter').setAttribute('data-list-id', data.id);
    node.querySelector('[name="list-id"]').value = data.id

    // in the new list, we add the 'add card' feature
    // why? Because this feature is applied to existing lists when the page loads, and not on newly created lists
    node.querySelector('.button--add-card').addEventListener('click', cardModule.showAddCardModal);

    // we add an event listener on the X to trigger the deletion of the list
    node.querySelector('.fa-times').closest('a').addEventListener('click', listModule.deleteList);

    // we call the SortableJS plugin
    // here we make cards draggable within lists
    // when thard dragging has ended, we trigger the listModule.handleDropCard method
    let container = node.querySelector('.panel-block');
    new Sortable(container, {
      group: "list",
      draggable: ".box",
      onEnd: listModule.handleDropCard
    });

    document.querySelector('.card-lists').appendChild(node);
  },

  deleteList: async event => {
    // asking the user to confirm deletion in order to avoid unvoluntary operations before definitively deleting DB records
    if (!confirm('Supprimer cette liste et les cartes qu\'elle contient ?')) {
      return;
    }

    const list = event.target.closest('.is-one-quarter');
    const listId = list.getAttribute('data-list-id');

    //DELETE /lists/id

    try {
      const result = await fetch(`${listModule.base_url}/lists/${listId}`, {
        method: 'DELETE'
      });

      if (result.ok) {
        // we remove the list from the DOM
        list.remove();
      } else {
        console.error('On a eu un pépin sur le serveur');
      }

    } catch (error) {
      console.error('Impossible de supprimer cette liste', error);
    }

  },

  showListNameForm: event => {
    // we make sure the h2 is hidden, we get a reference to it in event.target
    event.target.classList.add('is-hidden');
    // to grab the form, we have to start from the h2, the only reference to an HTML element we have here
    //we use the closest() method which goes up in the HTML hierarchy until it finds an element which contains the form we are trying to target
    const form = event.target.closest('.column').querySelector('form');
    // we make sure the form is displayed (not hidden)
    form.classList.remove('is-hidden');
    // in the input, we add the h2 content as value
    form.querySelector('[name="name"]').value = event.target.textContent;
  },

  handleListNameForm: async event => {
    event.preventDefault();
    // we create a FormData object based on the form
    const formData = new FormData(event.target);

    // we check if the user did type in something in the name field
    // if not, we exit the function and we display an error
    if (formData.get('name') === '') {
      console.error('Veuillez saisir un nom pour cette liste');
      return;
    }

    const h2 = event.target.closest('.is-one-quarter').querySelector('h2');

    try {
      // we update the list's name in the DB
      const result = await fetch(`${listModule.base_url}/lists/${formData.get('list-id')}`, {
        method: 'PATCH',
        body: formData
      });

      if (result.ok) {
        const json = await result.json();
        if (json) {
          h2.textContent = formData.get('name');
        } else {
          console.error('Mise à jour impossible, vérifiez les logs du serveur');
        }
      } else {
        console.error('On a eu pépin sur le serveur');
      }

    } catch (error) {
      console.error('Impossible de mettre la liste à jour', error);
    } finally {
      // we make sure the form is hidden
      event.target.classList.add('is-hidden');
      // we make the h2 visible again
      h2.classList.remove('is-hidden');

    }
  },
  closeEditListForm: (event) => {
    const listElement = event.target.closest('.column .is-one-quarter');

    // we hide the edit list name form
    const editForm = listElement.querySelector('form[method="PATCH"]');
    editForm.classList.add('is-hidden');
    // we make the list title visible again
    const h2 = listElement.querySelector('h2');
    h2.classList.remove('is-hidden');
  },
  handleDropList: (_) => {
    // when list dragging ended
    listModule.updateAllLists();
  },
  updateAllLists: () => {
    // when list dragging ended
    // we find all list items and we loop through them
    // we edit the position of each list
    document.querySelectorAll('.list-item').forEach((list, position) => {
      const listId = list.getAttribute('data-list-id');
      let data = new FormData();
      data.set('position', position);
      fetch(`${listModule.base_url}/lists/${listId}`, {
        method: "PATCH",
        body: data
      });
    });
  },
  // when card dragging has ended
  handleDropCard: (event) => {
    let originList = event.from;
    let targetList = event.to;

    // We are going to check both lists to update each card
    let cards = originList.querySelectorAll('.box');
    let listId = originList.closest('.list-item').getAttribute('data-list-id');
    // we provide info to update cards that were move within one list
    listModule.updateAllCards(cards, listId);

    if (originList !== targetList) {
      cards = targetList.querySelectorAll('.box')
      listId = targetList.closest('.list-item').getAttribute('data-list-id');
      // we provide info to update cards that were moved from one list to another
      listModule.updateAllCards(cards, listId);
    }
  },
  updateAllCards: (cards, listId) => {
    // for each card, we update position and/or list id in DB
    cards.forEach((card, position) => {
      const cardId = card.getAttribute('data-card-id');
      let data = new FormData();
      data.set('position', position);
      data.set('list_id', parseInt(listId, 10));
      fetch(`${listModule.base_url}/cards/${cardId}`, {
        method: "PATCH",
        body: data
      });
    });
  },
};

module.exports = listModule;

`${listModule.base_url}/lists`
},{"./cardModule":2}],4:[function(require,module,exports){
const utilsModule = require('./utilsModule');

const tagModule = {
  base_url: null,

  setBaseUrl: url => {
    tagModule.base_url = url;
  },
  makeTagInDOM: (tag, cardId) => {
    // we get the template
    const template = document.querySelector('#tagTemplateforCard');
    // we duplicate the HTML content from the template
    const newTag = document.importNode(template.content, true);
    // we update the tag name
    newTag.querySelector('.card__tag').textContent = tag.name;
    // we add the tag id as an attribute
    newTag.querySelector('.card__tag__column').setAttribute('data-tag-id', tag.id);

    newTag.querySelector('form input[name="card_id"]').value = cardId;
    newTag.querySelector('form input[name="id"]').value = tag.id;

    // upon click on the edit icon, we display the edit tag form
    newTag.querySelector('.card__tag').addEventListener('dblclick', tagModule.showEditTagForm);
    newTag.querySelector('form').addEventListener('submit', tagModule.handleEditTagForm);
    newTag.querySelector('.disassociate-tag').addEventListener('click', tagModule.handleDissociateTag);

    // we insert the tag in DOM within cards to which they are associated
    document.querySelector(`[data-card-id="${cardId}"] .card__tags`).appendChild(newTag);

    // we close the modal
    utilsModule.hideModals();

  },
  showAddTagForm: (_) => {
    // we get the add tag modal
    const tagModal = document.querySelector("#addTagModal");
    // we display the modal
    tagModal.classList.add('is-active');

  },
  showEditTagForm: (event) => {
    // we get the tag which is to be modified
    const tagElement = event.target.closest('.card__tag__column');

    // we display the edit form for that tag
    tagElement.querySelector('form').classList.remove("is-hidden");

    const input = tagElement.querySelector('form input[name="name"]');
    // we make sure the form input is automatically in focus 
    input.focus();

    // we hide the title
    tagElement.querySelector('.card__tag').classList.add('is-hidden');
  },
  handleEditTagForm: async (event) => {
    event.preventDefault();

    // we get the data from the form
    const formData = new FormData(event.target);
    const tagId = formData.get('id');
    const newTagTitle = formData.get('name');

    try {
      // we send a request to the API to save the title change in DB
      const requestParam = {
        method: 'PATCH',
        body: formData
      };
      const response = await fetch(`${tagModule.base_url}/tags/${tagId}`, requestParam);

      if (!response.ok) {
        // if there is an error
        const error = await response.json();
        throw error;
      }

      // If it works, we change the span textcontent with new name
      const tagElement = event.target.closest('.card__tag__column');
      tagElement.querySelector('.card__tag').textContent = formData.get('name');

      // we hide the form and we display the title again
      tagElement.querySelector('form').classList.add('is-hidden');
      tagElement.querySelector('.card__tag').classList.remove('is-hidden');

      // we modify the title in all cards which have this tag
      const tagInstances = document.querySelectorAll(`[data-tag-id="${tagId}"]`);
      for (const tagElement of tagInstances) {
        tagElement.textContent = newTagTitle;
      }

      // to avoid duplicates elements in DOM, we clear the tags block, then we get the new list of tags
      const tagsDivElement = document.querySelector(".tags__block");
      while (tagsDivElement.firstChild) {
        tagsDivElement.firstChild.remove();
      }
      tagModule.getTagsFromAPI();

    } catch (error) {
      console.log(error);
    }

  },
  handleAddTagForm: async (event) => {
    event.preventDefault();
    // we hide the error message in case it had been triggered during the last opening
    document.querySelector(".tag-exists").classList.add("is-hidden");

    // we get data from the form
    const formData = new FormData(event.target);
    formData.append('color', '#FFFFFF');

    try {
      // we check if this tag already exists in DB
      const response = await fetch(`${tagModule.base_url}/tags`);
      const tags = await response.json();
      const foundTag = tags.find(tag => {
        return tag.name === formData.get('name');
      });
      // If we find a tag with this name
      if (foundTag) {
        // we display an error message to the user
        document.querySelector(".tag-exists").classList.remove("is-hidden");
      } else {
        // If not, we add it in DB
        const requestParam = {
          method: 'POST',
          body: formData
        }

        const responseCreate = await fetch(`${tagModule.base_url}/tags`, requestParam);
        // If the operation succeeds
        if (responseCreate.ok) {
          const tag = await responseCreate.json();
          // we add the tag in the DOM (tags block)
          // for that, we get the tag template 
          const template = document.querySelector('#tagTemplateforTagList');
          // we duplicate the HTML contained in the template
          const newTag = document.importNode(template.content, true);
          // we update the element text with the new tag name
          newTag.querySelector('.card__tag').textContent = tag.name;
          // we add the tag id as an attribute
          newTag.querySelector('.card__tag__column').setAttribute('data-tag-id', tag.id);
          newTag.querySelector('form input[name="card_id"]').value = tag.card_id;
          newTag.querySelector('form input[name="id"]').value = tag.id;
          // upon double-click on a tag, we display the tag edit form
          newTag.querySelector('.card__tag').addEventListener('dblclick', tagModule.showEditTagForm);
          newTag.querySelector('form').addEventListener('submit', tagModule.handleEditTagForm);
          newTag.querySelector('.delete-tag').addEventListener('click', tagModule.deleteTag);
          // we insert the new tag in DOM
          document.querySelector(".tags__block").appendChild(newTag);

          // we close the modal
          utilsModule.hideModals();
        }
        else {
          const error = await responseCreate.json();
          throw error;
        }
      }
    } catch (error) {
      console.log(error);
    }

  },
  getTagsFromAPI: async () => {
    // we get all the tags from DB
    try {
      const response = await fetch(`${tagModule.base_url}/tags`);
      const tags = await response.json();
      for (const tag of tags) {
        // we get the template 
        const template = document.querySelector('#tagTemplateforTagList');
        // we duplicate the HTML contained in the template
        const newTag = document.importNode(template.content, true);
        // we update the element text with the new tag name
        newTag.querySelector('.card__tag').textContent = tag.name;
        // we add the tag id as an attribute
        newTag.querySelector('.card__tag__column').setAttribute('data-tag-id', tag.id);
        newTag.querySelector('form input[name="card_id"]').value = tag.card_id;
        newTag.querySelector('form input[name="id"]').value = tag.id;
        // upon double-click on a tag, we display the tag edit form
        newTag.querySelector('.card__tag').addEventListener('dblclick', tagModule.showEditTagForm);
        newTag.querySelector('form').addEventListener('submit', tagModule.handleEditTagForm);
        newTag.querySelector('.delete-tag').addEventListener('click', tagModule.deleteTag);

        // we insert the tag in the DOM (tags block)
        document.querySelector(".tags__block").appendChild(newTag);

      }
    } catch (error) {
      console.log(error);
    }
  },
  showAssociateLabelForm: async (event) => {
    // if it is not the first time this form is used, we need to clear the last selection
    const selectElement = document.getElementById('label-select');
    for (const option of selectElement.options) {
      if (option.value === 'default') {
        option.selected = true;
      } else {
        option.selected = false;
      }
    }

    // we get the value of data-list-id by using the reference to the clicked element
    const cardId = event.target.closest('.box').getAttribute('data-card-id');

    // we add it in a hidden input in the form
    const associateTagModal = document.getElementById("associateTagModal");
    associateTagModal.querySelector('input[name="card-id"]').value = cardId;
    // we make the modal visible
    associateTagModal.classList.add('is-active');

    try {
      // we get all tags in DB
      const response = await fetch(`${tagModule.base_url}/tags`);
      const tags = await response.json();

      // to avoid duplicates and to plan for newly added tags,
      // we check first if tag options are already present in the DOM
      // if so, we are going to make sur we add only new tags
      // that were not in DB at the last modal opening
      if (selectElement.children.length > 1) {
        // we transform the HTML Collectrion into an array so we can iterate through it
        const optionsArray = Array.from(selectElement.children);

        for (const tag of tags) {
          // if the tag from the DB is found in the DOM
          if (optionsArray.some(option => parseInt(option.value) === tag.id)) {
            // we don't do anything
            return;
          } else {
            // if not, it means this new tag needs to be inserted in DOM
            const option = document.createElement('option');
            option.textContent = tag.name;
            option.defaultSelected = false;
            option.setAttribute('value', tag.id);
            selectElement.appendChild(option);
          }
        }
      } else {
        // if it is the time the modal is opening, the drop down is empty in DOM
        // we can directly insert each tag from DB
        for (const tag of tags) {
          const option = document.createElement('option');
          option.textContent = tag.name;
          option.defaultSelected = false;
          option.setAttribute('value', tag.id);
          selectElement.appendChild(option);
        }
      }


    } catch (error) {
      console.log(error);
    }
  },

  handleAssociateLabelForm: async (event) => {
    event.preventDefault();
    const formData = new FormData(event.target);
    const cardId = formData.get('card-id');
    console.log('carotte');

    for (var pair of formData.entries()) {
      // we loop through tag ids in formdata
      if (pair[0] === 'tag-id' && pair[1] !== 'default') {
        console.log('patate');
        const tagId = parseInt(pair[1], 10);

        // we check if this tag is already associated with this card
        try {
          const response = await fetch(`${tagModule.base_url}/cards/${cardId}`);
          console.log('poireau');
          if (response.ok) {
            console.log('chou');
            const card = await response.json();

            const foundTag = card.tags.find(tag => tag.id === tagId);
            console.log(foundTag);
            if (!foundTag) {
              //  if the association doesn't already exist, we can save it in DB
              // and add the tag in the DOM (card container)
              const associateFormData = new FormData();
              associateFormData.append('tag_id', tagId);

              const requestParam = {
                method: 'POST',
                body: associateFormData
              }
              const response = await fetch(`${tagModule.base_url}/cards/${cardId}/tags`, requestParam);
              if (response.ok) {
                const newAssociation = await response.json();

                // we need the full info on the tag to pass it on to the makeTagInDOM method
                const fullTag = newAssociation.tags.find(tag => tag.id === tagId);
                tagModule.makeTagInDOM(fullTag, cardId);
              }
              else {
                const error = await response.json();
                throw error;
              }
            } else {
              utilsModule.hideModals();
            }
          }
          else {
            const error = await response.json();
            throw error;
          }
        } catch (error) {
          console.log(error);
        }
      }
    }
  },
  handleDissociateTag: async (event) => {
    // we get the span element of the tag name
    const tagElement = event.target.closest('.card__tag__column');
    const tagId = tagElement.getAttribute("data-tag-id");
    const cardElement = event.target.closest('.box');

    const cardId = cardElement.getAttribute('data-card-id');
    // we send a fetch request with method DELETE
    try {
      const requestParam = {
        method: 'DELETE'
      };

      const response = await fetch(`${tagModule.base_url}/cards/${cardId}/tags/${tagId} `, requestParam);

      if (!response.ok) {
        // If the operation doesn't succeed
        const error = await response.json();
        throw error;
      }

      // If the operation succeeds, we remove the tag from the DOM within this card
      const result = await response.json();
      tagElement.remove();

    } catch (error) {
      console.log(error);
    }
  },
  deleteTag: async (event) => {
    // we get the span element of the tag name
    const tagElement = event.target.closest('.card__tag__column');
    const tagId = tagElement.getAttribute("data-tag-id");
    // we send a fetch request with method DELETE
    try {
      const requestParam = {
        method: 'DELETE'
      };
      const response = await fetch(`${tagModule.base_url}/tags/${tagId}`, requestParam);
      if (!response.ok) {
        // if the operation fails
        const error = await response.json();
        throw error;
      }

      // If the operation succeeds, we remove the tag from the DOM (tags block)
      tagElement.remove();

      // still in the DOM, we remove the tag from all cards it is associated to
      const tagsWithThisId = document.querySelectorAll(`[data-tag-id="${tagId}"]`);
      for (const tag of tagsWithThisId) {
        tag.remove();
      }

    } catch (error) {
      console.log(error);
    }

  }
};

module.exports = tagModule;

},{"./utilsModule":5}],5:[function(require,module,exports){

const utilsModule = {
  hideModals: () => {
    // we grab all elements with 'modal' class
    const modals = document.querySelectorAll('.modal');
    // we run a loop on the array and, for each element, we remove 'is-active' class
    for (const modal of modals) {
      modal.classList.remove('is-active');
    }
  },
}

module.exports = utilsModule;
},{}]},{},[1]);
